---
title: "Analisis Factorial"
author: "Miguel Angel Gonz√°lez Guti√©rrez"
date: "2025-10-23"
output: pdf_document
---

```{r}
# Cargar paquetes
library(readxl)
library(dplyr)
library(MVN)
library(psych)
library(performance)
library(GPArotation)
library(tidyr)
library(reshape2)
library(corrplot)
```


Leer datos. Estan Estandarizados para aplicar un analisis factorial.
```{r}
df <- read_excel("MICE_STD.xlsx")
glimpse(df)
```
```{r}
names(df_num)
```


Mantener solo numericas y quitar columna mes.
```{r}
df_num <- dplyr::select_if(df, is.numeric)
df_num <- dplyr::select(df_num, -mes)
df_num <- dplyr::select(df_num, 3:8)
glimpse(df_num)
```

Revisar normalidad conjunta e individual. Tomar una muestra aleatoria de 10k filas
```{r}
set.seed(123)
df_sample <- df_num[sample(nrow(df_num), 10000), ]  # muestra de 10000 filas

resultado <- mvn(df_sample, mvnTest = "mardia")
resultado$multivariateNormality
resultado$univariateNormality
```
Segun test de Mardia, no siguen una normal multivariada. Tampoco lo es en el caso individual para cada variable. Estimaciones por M√°xima Verosimilitud descartadas.


Verificar medias a lo largo del d√≠a para establecer periodos de tiempo y acortar informacion. Mantener informacion representativa a estos periodos de tiempo.
```{r}
df$hora <- as.numeric(format(df$fecha_y_hora, "%H"))
library(dplyr)

resumen_hora <- df %>%
  group_by(hora) %>%
  summarise(
    media_sr_kw_m2 = mean(sr_kw_m2, na.rm = TRUE),
    media_wsr_km_h = mean(wsr_km_h, na.rm = TRUE)
  )

library(ggplot2)

ggplot(resumen_hora, aes(x = hora, y = media_sr_kw_m2)) +
  geom_line(color = "orange", size = 1) +
  labs(x = "Hora del d√≠a", y = "Media sr_kw_m2", title = "Media diaria de sr_kw_m2") +
  theme_minimal()

ggplot(resumen_hora, aes(x = hora, y = media_wsr_km_h)) +
  geom_line(color = "blue", size = 1) +
  labs(x = "Hora del d√≠a", y = "Media wsr_km_h", title = "Media diaria de wsr_km_h") +
  theme_minimal()
```
Cambios m√°s notorios identificados por:
7 - 13
13 - 17
17 - 7


Sin embargo, no fue necesario utilizarlas.


Matriz de correlaciones
```{r}
Corr <- corr.test(df_num, adjust = "none")  # adjust="none" para no ajustar p-values
```

Aplicar prueba de correlacion
```{r}
check_sphericity_bartlett(df_num)


b <- check_sphericity_bartlett(df_num)
b$chisq
b$dof
b$p
```
valor p cero, existe correlacion conjunta significativa. Valor Chisq altisimo, buen indicio para afirmar que hay presencia de correlacion conjunta.

```{r}
kmo_result <- KMO(cor(df_num))
kmo_result
```
Buena metrica para el coeficiente KMO, aceptable. De forma individual, la mayoria ronda el 0.7, a excepci√≥n de la variable de Ozono.


Establecer cantidad optima de factores.
```{r}
scree(df_num)
fa.parallel(df_num, fm = "ml", fa = "fa")
```
Convergencia parece cruzar en 4 factores.


```{r}
modelo1 <- fa(df_num, nfactors = 3, rotate = "none", fm = "mle")
print(modelo1, cut = 0.3)

modelo2 <- fa(df_num, nfactors = 3, rotate = "none", fm = "minres")
print(modelo2, cut = 0.3)
```
Sin embargo, el cuarto factor resulta irrelevante. Se mantendr√° el numero de factores en tres.


Agregar graficas.
```{r}
# Modelo con rotaci√≥n Varimax
modelo2V <- fa(df_num, nfactors = 3, rotate = "varimax", fm = "minres")

# Mostrar las cargas factoriales (solo > 0.3)
print(modelo1V$loadings, cut = 0.3)


modelo2Q <- fa(df_num, nfactors = 3, rotate = "quartimax", fm = "minres")
print(modelo1Q$loadings, cut = 0.3)
```
Observamos Loadings para cada factor. Al no seguir una normalidad el conjunto de datos, descartamos utilizar Maxima Verosimilitud. Priorizaremos QuartiMax para minimizar el numero de factores necesarios para explicar cada variable.

```{r}
fa.diagram(modelo2V, main="Rotaci√≥n Varimax, M√©todo MLE")
```
```{r}
fa.diagram(modelo2Q, main="Rotaci√≥n Quartimax, M√©todo minres")
```

```{r}
biplot.psych(modelo2Q, main="Rotaci√≥n Varimax", sub="M√©todo MLE", col=c("gray","red"))

biplot.psych(modelo2Q, main="Rotaci√≥n Quartimax", sub="M√©todo MLE", col=c("gray","blue"))
```



Cargar informacion para revisar correlaciones de temperaturas entre alturas
```{r}
touts <- read_excel("MICE_con_altura.xlsx")
glimpse(touts)
```
```{r}
unique(touts$`__hoja`)
```
```{r}
# Vector con el orden deseado (por alturas en orden ascendente)
orden_estaciones <- c("NORESTE2", "NORESTE", "SURESTE", "NORTE", 
                      "NORTE2", "SUR", "CENTRO", "NOROESTE", 
                      "SUROESTE2", "SUROESTE")

# Probar filtrando por la estacion Primavera
primavera <- touts %>% filter(estacion == "Primavera")

# Convertimos ___hoja a factor con niveles en el orden deseado
primavera$`__hoja` <- factor(primavera$`__hoja`, levels = orden_estaciones)

# Reordenamos las filas del dataframe seg√∫n este factor
primavera <- primavera %>% arrange(`__hoja`)
```

```{r}
# Vector con las estaciones del a√±o
estaciones_ano <- c("Primavera", "Verano", "Oto√±o", "Invierno")

# Bucle para generar un corrplot por cada estaci√≥n del a√±o
for (e in estaciones_ano) {
  
  # 1Ô∏è‚É£ Filtrar por estaci√≥n del a√±o
  df_temp <- touts %>% filter(estacion == e)
  
  # 2Ô∏è‚É£ Convertir ___hoja a factor (para asegurar orden)
  df_temp$`__hoja` <- factor(df_temp$`__hoja`, levels = orden_estaciones)
  
  
  
  # 3Ô∏è‚É£ Pivotear a formato ancho
  df_wide <- df_temp %>%
    select(`__hoja`, `tout_¬∫c`) %>%
    group_by(`__hoja`) %>%
    mutate(id = row_number()) %>%
    ungroup() %>%
    pivot_wider(names_from = `__hoja`, values_from = `tout_¬∫c`) %>%
    select(all_of(orden_estaciones))  # üîπ forzar orden de columnas
  
  # 4Ô∏è‚É£ Calcular matriz de correlaciones
  matriz_cor <- cor(df_wide, use = "pairwise.complete.obs")
  
  # 5Ô∏è‚É£ Graficar
  corrplot(matriz_cor, method = "color",
           type = "upper", diag = FALSE,
           col = colorRampPalette(c("blue", "red"))(200),
           is.corr = FALSE,
           tl.col = "black", tl.cex = 0.8,
           addCoef.col = "black", number.cex = 0.6,
           title = paste(e),
           mar = c(0,0,4,0))
}
```


Analizar distribuciones cuando 
IT = 1, 0
```{r}
df <- read_excel("MICE_con_inversion_termica_BLOQHORARIA.xlsx")
glimpse(df)
```
```{r}
df <- df %>%
  mutate(
    factor1_ML2 = 0.418*co_ppm + 0.817*pm10_ug_m3 + 0.827*pm2_5_ug_m3,
    factor2_ML1 = 0.974*so2_ppb,
    factor3_ML3 = 0.651*no2_ppb - 0.589*o3_ppb
  )
```

```{r}
set.seed(123)
sample_df <- df %>% sample_n(5000)

shapiro.test(sample_df$factor1_ML2)
shapiro.test(sample_df$factor2_ML1)
shapiro.test(sample_df$factor3_ML3)
```

```{r}
# Configuramos la ventana con 3 gr√°ficos lado a lado
par(mfrow = c(1, 3))

# QQ Plot para el Factor 1 (ML2)
qqnorm(df$factor1_ML2, main = "QQ Plot - Factor 1 (ML2)",
       col = "blue", pch = 19, cex = 0.5)
qqline(df$factor1_ML2, col = "red", lwd = 2)

# QQ Plot para el Factor 2 (ML1)
qqnorm(df$factor2_ML1, main = "QQ Plot - Factor 2 (ML1)",
       col = "blue", pch = 19, cex = 0.5)
qqline(df$factor2_ML1, col = "red", lwd = 2)

# QQ Plot para el Factor 3 (ML3)
qqnorm(df$factor3_ML3, main = "QQ Plot - Factor 3 (ML3)",
       col = "blue", pch = 19, cex = 0.5)
qqline(df$factor3_ML3, col = "red", lwd = 2)

# Restaurar la configuraci√≥n gr√°fica original
par(mfrow = c(1, 1))
```

```{r}
ggplot(df, aes(x = as.factor(Inversion_Termica_slot), y = factor1_ML2)) +
  geom_boxplot(fill = c("#91bfdb", "#fc8d59")) +
  labs(
    x = "Inversi√≥n t√©rmica (0 = No, 1 = S√≠)",
    y = "Factor 1 (PM2.5, PM10, CO)",
    title = "Distribuci√≥n del Factor 1 seg√∫n inversi√≥n t√©rmica"
  ) +
  theme_minimal(base_size = 13)
```

```{r}
ggplot(df, aes(x = as.factor(Inversion_Termica_slot), y = factor2_ML1)) +
  geom_boxplot(fill = c("#b2df8a", "#fb9a99")) +
  labs(
    x = "Inversi√≥n t√©rmica (0 = No, 1 = S√≠)",
    y = "Factor 2 (SO‚ÇÇ)",
    title = "Distribuci√≥n del Factor 2 seg√∫n inversi√≥n t√©rmica"
  ) +
  theme_minimal(base_size = 13)
```

```{r}
ggplot(df, aes(x = as.factor(Inversion_Termica_slot), y = factor3_ML3)) +
  geom_boxplot(fill = c("#a6cee3", "#fdbf6f")) +
  labs(
    x = "Inversi√≥n t√©rmica (0 = No, 1 = S√≠)",
    y = "Factor 3 (NO‚ÇÇ / O‚ÇÉ)",
    title = "Distribuci√≥n del Factor 3 seg√∫n inversi√≥n t√©rmica"
  ) +
  theme_minimal(base_size = 13)
```




